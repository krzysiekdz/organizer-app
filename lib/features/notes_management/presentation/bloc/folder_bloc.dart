import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import '../../domain/entities/folder.dart';
import '../../domain/repositories/folder_repository.dart';

part 'folder_event.dart';
part 'folder_state.dart';

class FolderBloc extends Bloc<FolderEvent, FolderState> {
  final FolderRepository folderRepository;
  final String userId;
  final String? parentId;
  StreamSubscription<List<Folder>>? _foldersSubscription;

  FolderBloc({
    required this.folderRepository,
    required this.userId,
    required this.parentId,
  }) : super(FolderLoading()) {
    on<LoadFolders>(_onLoadFolders);
    on<LoadFoldersByParentId>(_onLoadFoldersByParentId);
    on<CreateFolder>(_onCreateFolder);
    on<UpdateFolder>(_onUpdateFolder);
    on<DeleteFolder>(_onDeleteFolder);
    on<FoldersChanged>(_onFoldersChanged);

    // Listen to folder collection changes for this view (e.g. edits from another device)
    _foldersSubscription = folderRepository.watchFolders(userId, parentId).listen(
          (folders) => add(FoldersChanged(folders: folders)),
        );
  }

  @override
  Future<void> close() {
    _foldersSubscription?.cancel();
    return super.close();
  }

  Future<void> _onLoadFolders(
      LoadFolders event, Emitter<FolderState> emit) async {
    emit(FolderLoading());
    try {
      final folders = await folderRepository.getFolders(userId);
      emit(FolderLoaded(folders: folders, parentId: parentId));
    } catch (e) {
      emit(FolderError(message: e.toString()));
    }
  }

  Future<void> _onLoadFoldersByParentId(
      LoadFoldersByParentId event, Emitter<FolderState> emit) async {
    emit(FolderLoading());
    try {
      final folders = await folderRepository.getFoldersByParentId(
        userId,
        parentId,
      );
      emit(FolderLoaded(folders: folders, parentId: parentId));
    } catch (e) {
      emit(FolderError(message: e.toString()));
    }
  }

  void _onFoldersChanged(FoldersChanged event, Emitter<FolderState> emit) {
    // Stream already filtered by this bloc's parentId
    emit(FolderLoaded(folders: event.folders, parentId: parentId));
  }

  Future<void> _onCreateFolder(
      CreateFolder event, Emitter<FolderState> emit) async {
    try {
      final folder = Folder(
        id: '', // Will be generated by repository
        name: event.name,
        parentId: event.parentId,
        userId: userId,
        createdAt: DateTime.now(),
      );
      await folderRepository.createFolder(folder);
      add(LoadFoldersByParentId(parentId: event.parentId));
    } catch (e) {
      emit(FolderError(message: e.toString()));
    }
  }

  Future<void> _onUpdateFolder(
      UpdateFolder event, Emitter<FolderState> emit) async {
    try {
      await folderRepository.updateFolder(event.folder);
      final currentState = state;
      if (currentState is FolderLoaded) {
        final updatedFolders = currentState.folders.map((folder) {
          return folder.id == event.folder.id ? event.folder : folder;
        }).toList();
        emit(FolderLoaded(
          folders: updatedFolders,
          parentId: parentId,
        ));
      }
    } catch (e) {
      emit(FolderError(message: e.toString()));
    }
  }

  Future<void> _onDeleteFolder(
      DeleteFolder event, Emitter<FolderState> emit) async {
    try {
      await folderRepository.deleteFolder(event.folderId);
      final currentState = state;
      if (currentState is FolderLoaded) {
        final updatedFolders = currentState.folders
            .where((folder) => folder.id != event.folderId)
            .toList();
        emit(FolderLoaded(
          folders: updatedFolders,
          parentId: parentId,
        ));
      }
    } catch (e) {
      emit(FolderError(message: e.toString()));
    }
  }
}

